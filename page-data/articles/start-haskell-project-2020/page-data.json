{"componentChunkName":"component---src-templates-article-template-js","path":"/articles/start-haskell-project-2020","result":{"data":{"markdownRemark":{"html":"<p>Let's face it, Haskell has a bad reputation.\nIt is known as a complicated programming language, very different from the others, which has a steep learning curve and low accessibility to newcomers.\nAs a pretty recent Haskeller, in my humble opinion, the fact that Haskell's tooling is a mess must have been one of the most frightening thing for beginners.</p>\n<p>I remember a year ago when I tried to start my very first Haskell project, I got very confused about which way Haskell applications should be created, written, built and run.\nThis is clearly the worst thing that can happen to any beginner in any technology: not being able to have a \"Hello World\" app in a few minutes.</p>\n<p>I think Haskell is an amazing language which is worth learning.\nThere are probably even more <a href=\"https://serokell.io/blog/10-reasons-to-use-haskell\">posts about Haskell's greatness</a> than posts against it.\nBut it all goes to nothing if you can't convince others to use it because the ecosystem is just not usable.</p>\n<p>Developers now have a pretty high standard about programming ecosystem, and they are right!\nThe Haskell community has worked hard and many improvements have landed in 2020, making it much more usable.</p>\n<p>Are you a beginner who wants to try Haskell?\nWelcome, I'll help you setup your project and run your first \"Hello world\"!</p>\n<h3>What this guide is not about</h3>\n<ul>\n<li>This guide is not about \"the best way to create a Haskell project\"</li>\n<li>This guide is not about \"the fastest way to create a Haskell project\"</li>\n</ul>\n<h2>The modern code editor: VS Code</h2>\n<p>In this guide, we will use <strong>VS Code</strong> as our code editor.\nVS Code is for me a very versatile editor, not too heavy, extensible, and can be turned into an IDE for almost any programming language thanks to the <a href=\"https://microsoft.github.io/language-server-protocol/\">LSP protocol</a>.</p>\n<blockquote>\n<p>The idea behind the Language Server Protocol (LSP) is to standardize the protocol for how such servers and development tools communicate.\nThis way, a single Language Server can be re-used in multiple development tools, which in turn can support multiple languages with minimal effort.</p>\n</blockquote>\n<p>You can install VS Code here: <a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a></p>\n<p>After installing VS Code, we need to install the <a href=\"https://marketplace.visualstudio.com/items?itemName=haskell.haskell\">Haskell VS Code extension</a>.\nIt is a very recent extension that will allow us to use HLS, the <strong>Haskell Language Server</strong> (<a href=\"https://github.com/haskell/haskell-language-server\">learn more about it here</a>).</p>\n<blockquote>\n<p>A bit of background: for a very long time, Haskell did not have any IDE.\nSome people developped HIE, Haskell IDE Engine, but it was very heavy.\nSome other people developped GHCIDE, a lightweight IDE engine, but it lacked functionality.\nThe two teams decided to <a href=\"https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html\">join forces</a>, giving birth to HLS, \"one IDE to rule them all\".</p>\n</blockquote>\n<p>If you are on one of the most common OS (Windows, MacOS or Linux), the extension will automatically download the binaries of the Haskell Language Server for you.\nYou have nothing more to do than to install the VSCode extension!</p>\n<blockquote>\n<p>If you have a more exotic OS or installation, you might need to <a href=\"https://github.com/haskell/haskell-language-server#installation\">install HLS yourself</a>.\nFill an issue <a href=\"https://github.com/haskell/haskell-language-server/issues\">here</a> if you have trouble doing so.</p>\n</blockquote>\n<p>Open VS Code, create a folder for our Haskell project (e.g. <code>/home/youruser/haskell-guide</code> on Linux or <code>C:\\Users\\youruser\\haskell-guide</code> on Windows).\n<strong>From this point onward, this guide will consider this folder to be the current working directory.</strong></p>\n<blockquote>\n<p>If you have never used VS Code, consider following <a href=\"https://code.visualstudio.com/docs\">its official guide</a>.</p>\n</blockquote>\n<h2>Create a Haskell project using Stack</h2>\n<h3>Understanding the tools</h3>\n<p>The tools we will be using are <strong>GHC</strong>, <strong>Cabal</strong> and <strong>Stack</strong>.\nIt is important to understand what each one of them does.</p>\n<p>The <strong>Glasgow Haskell Compiler</strong>, or <a href=\"https://www.haskell.org/ghc/\">GHC</a>, is the most widespread and used compiler for Haskell.\nIt is the program in charge of turning your Haskell files into binaries, much like <code>gcc</code> in the C ecosystem.\nClose to GHC is GHCi, which is a tool to run interactively Haskell in a REPL.\nMost Haskell tutorials will make you <a href=\"https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html\">use GHCi to play around with Haskell</a>, but that is not our purpose here.</p>\n<blockquote>\n<p>Note that other compilers exist, for instance <a href=\"https://github.com/ghcjs/ghcjs\">GHCJS</a> which turns Haskell code into JavaScript.</p>\n</blockquote>\n<p>Like <code>gcc</code>, it is very tedious to use GHC by hand, especially once you want to use other librairies as dependencies.</p>\n<p>Here comes <strong>Cabal</strong>, <a href=\"https://www.haskell.org/cabal/\">a system for building and packaging Haskell librairies and applications</a>.\nIt is pretty much the standard packaging tool used in the Haskell ecosystem.\nMuch like <code>CMake</code> in C, <code>Maven</code> in Java or <code>npm</code> in JavaScript, the user writes a file defining the package and the tool automate a lot of tasks.</p>\n<blockquote>\n<p>Early note to save you time later: do <em>not</em> think of <code>cabal install</code> as <code>npm install</code>, they are not the same. Just <em>do not use it</em>, never. Not until a later time.</p>\n</blockquote>\n<p>While Cabal could be sufficient to create a Haskell package, one would still have to manage many different things to get a program to compile.\nWhich GHC version? How to install dependencies? How to compile everything for the right GHC version?\nIt's all too tedious for us for now.\nFortunatly, there's another too for use.</p>\n<p>Meet the \"Haskell Tool Stack\", or <strong>Stack</strong>, a <a href=\"https://docs.haskellstack.org/en/stable/README/\">cross-platform program for developping Haskell projects</a>.\n<strong>Stack will be the only tool we interact with</strong>.\nIt is on top of Cabal and GHC and will automate and simplify our workflow by calling Cabal whenver it is needed, which will call GHC whenever it is needed.</p>\n<blockquote>\n<p>If you are on NixOS, be mindful that Stack will automatically enable <a href=\"https://docs.haskellstack.org/en/stable/nix_integration/\">Nix support</a>.</p>\n</blockquote>\n<h3>Stack in practice</h3>\n<p>First, install it following the <a href=\"https://docs.haskellstack.org/en/stable/README/#how-to-install\">official instructions</a>.</p>\n<h4>Configure Stack</h4>\n<p>We now need to configure Stack for our project.\nThis is done by creating a <code>./stack.yaml</code> file:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Use LTS of Stackage for GHC 8.4.4</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># https://www.stackage.org/lts-16.26</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">resolver</span><span class=\"mtk1\">: </span><span class=\"mtk11\">lts-16.26</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Local packages</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">packages</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  - </span><span class=\"mtk11\">./helloworld</span></span></span></code></pre>\n<p>Let's walk through this file, there are some really important things here.</p>\n<h5><code>resolver</code>: define Stackage snapshot</h5>\n<p>The <code>resolver</code> attribute defines which snapshot of Stackage the Stack tool should use.</p>\n<p>Stackage is a <a href=\"https://www.stackage.org/\">repository of packages</a>.\nWhile <a href=\"https://hackage.haskell.org/\">Hackage</a> is the official package repository where all Haskell packages are published, Stackage provides regular \"package sets\" (snapshots) that each corresponds to a GHC version and comprises Haskell packages that all build together.\nThis is very handy to ensure that you don't have major compatibility problems between dependencies, without being aware of potential breaks.</p>\n<blockquote>\n<p>It is important to understand that Haskell, while being ready for commercial use, is also a subject of research and development.\nThis means that <strong>things can get very different between GHC version</strong>.\nWhile new functionalities are often published, things can suddendly break after an upgrade of GHC.\nIf you are a beginner, you should most likely use a fairly recent version of GHC and stick with it for a while.</p>\n</blockquote>\n<p>In this guide, I will use the <a href=\"https://www.stackage.org/lts-16.26\"><code>lts-16.26</code></a> snapshot, which corresponds to the package set for GHC 8.4.4.\nYou can find all snapshots <a href=\"https://www.stackage.org/snapshots\">on their website</a>.</p>\n<h5><code>packages</code>: define local packages</h5>\n<p>A project defined with Stack can hold multiple packages.\nA project repository holding multiple packages (librairies and programs) is often called a \"monorepo\".</p>\n<p>The <code>packages</code> attribute should hold a list, each element representing a path to a subfolder holding a package.\nIn this guide, we will have only one package, contained in the <code>./helloworld</code> directory.</p>\n<h4>Create a package</h4>\n<p>Create the subfolder <code>./helloworld</code>.</p>\n<p>When using Stack, we can define a package using <a href=\"https://github.com/sol/hpack\"><code>hpack</code></a>.\nWhat we have to do is to simply create a <code>package.yaml</code> file.\nStack will call <code>hpack</code>, which will turn it magically into a Cabal project for us!</p>\n<p>Let's write to the <code>./helloworld/package.yaml</code> file:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">name</span><span class=\"mtk1\">: </span><span class=\"mtk11\">helloworld</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">version</span><span class=\"mtk1\">: </span><span class=\"mtk5\">0.0.0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">description</span><span class=\"mtk1\">: </span><span class=\"mtk11\">My first Haskell package</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  - </span><span class=\"mtk11\">base</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">library</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">source-dirs</span><span class=\"mtk1\">: </span><span class=\"mtk11\">./src/lib</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">executable</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">source-dirs</span><span class=\"mtk1\">: </span><span class=\"mtk11\">./src/exe</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">main</span><span class=\"mtk1\">: </span><span class=\"mtk11\">Main</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    - </span><span class=\"mtk11\">helloworld</span></span></span></code></pre>\n<p>Again, let's walk this file together!</p>\n<h5><code>name</code>, <code>version</code> and <code>description</code></h5>\n<p>Some attributes are purely descriptive.\nYou can guess the meaning of <code>name</code>/<code>version</code>/<code>description</code>.\nThere are some <a href=\"https://github.com/sol/hpack#top-level-fields\">other attributes</a> that you can use, for instance <code>author</code>, <code>license</code>, <code>github</code>, ...</p>\n<h5><code>dependencies</code></h5>\n<p>Like any ecosystem, we can make librairies and applications that rely on other libraries in order not to code everything ourselves.</p>\n<p>This list defines the packages that our package depends on, from the selected resolver (that we have chosen before in <code>stack.yaml</code>).\nThis is very much like any kind of dependency definition, same as in <code>package.json</code> for JavaScript or <code>requirements.txt</code> for Python.</p>\n<p>Our project will not have any \"external\" dependency, but we still need to include the <code>base</code> package which is Haskell's standard library:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  - </span><span class=\"mtk11\">base</span></span></span></code></pre>\n<p>Imagine you would want to use the <a href=\"https://hackage.haskell.org/package/text\"><code>text</code> package</a>, simply set <code>dependencies</code> to:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  - </span><span class=\"mtk11\">base</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  - </span><span class=\"mtk11\">text</span></span></span></code></pre>\n<h5><code>library</code></h5>\n<p>A Haskell package defined with Stack can be split into components: library, executables, tests.</p>\n<p>The <code>library</code> attribute will allow us to define everything about the library component of our package.</p>\n<blockquote>\n<p>Note that only the library component can be imported when using another package as dependency.\nUsually, almost everything in a package is defined in the library component, and the executables and tests only make the right calls in the internal library.</p>\n</blockquote>\n<p>Each component of the package can be stored in its own folder.\nHere, I specify that all the Haskell source code for the library component of our package will be in <code>./helloworld/src/lib</code> using the <code>library.source-dirs</code> attribute:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">library</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">source-dirs</span><span class=\"mtk1\">: </span><span class=\"mtk11\">./src/lib</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk5\">...</span></span></span></code></pre>\n<p>The path given to <code>library.source-dirs</code> is relative to the <code>package.yaml</code> file of the package.</p>\n<p>There are many more attributes you can define, but right now this is enough.</p>\n<h5><code>executable</code></h5>\n<p>Since we want to make an executable that says \"Hello world\", we need to define an executable component in our package.\nThe <code>executable</code> attribute defines just that!</p>\n<blockquote>\n<p>A package can define multiple executable components, but <code>executable</code> is useful when there is only one executable component to define.</p>\n</blockquote>\n<p>The <code>executable.source-dirs</code> attribute is the same as <code>library.source-dirs</code>.\nHere, all the source code for the executable of our package will be in <code>./helloworld/src/exe</code>.</p>\n<p>The difference is the <code>executable.main</code>:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">executable</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk5\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">main</span><span class=\"mtk1\">: </span><span class=\"mtk11\">Main</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk5\">...</span></span></span></code></pre>\n<p><code>executable.main</code> defines which Haskell module (basically which source file) contains the <code>main</code> top-level definition.\nBasically, the entry point of our executable will be in <code>./helloworld/src/exe/Main.hs</code>.\nWorry not about all that, I will tell you more in a moment!</p>\n<p>What might come as unexpected is that, by default, the executable and test components do not define the library of the same package as a dependency.\nThis has to be defined manually, for instance in <code>executable.dependencies</code>:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">executable</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk5\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    - </span><span class=\"mtk11\">helloworld</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk5\">...</span></span></span></code></pre>\n<h4>Let's code !</h4>\n<p>Our package has the following structure:</p>\n<ul>\n<li>\n<p><code>helloworld</code> folder</p>\n<ul>\n<li><code>package.yaml</code> file</li>\n<li>\n<p><code>src</code> folder</p>\n<ul>\n<li><code>lib</code> folder</li>\n<li><code>exe</code> folder</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>First, let's create a simple source file for our library, <code>./helloworld/src/lib/Helloworld.hs</code>:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"haskell\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"1\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">module</span><span class=\"mtk1\"> Helloworld (message) </span><span class=\"mtk4\">where</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"2\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"3\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">message </span><span class=\"mtk4\">::</span><span class=\"mtk1\"> </span><span class=\"mtk4\">String</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"4\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">message = </span><span class=\"mtk11\">&quot;Hello world&quot;</span></span></span></code></pre>\n<p>and then define our executable source code in <code>./helloworld/src/exe/Main.hs</code>:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"haskell\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"1\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">module</span><span class=\"mtk1\"> Main </span><span class=\"mtk4\">where</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"2\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"3\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">import</span><span class=\"mtk1\"> Helloworld (message)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"4\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"5\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">main = putStrLn message</span></span></span></code></pre>\n<p>We can then compile our project using:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"bash\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">stack build</span></span></span></code></pre>\n<p>or run the executable using</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"bash\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">stack run</span></span></span></code></pre>\n<p>which should say, after some compilation gibberish... \"Hello world\" !</p>\n<h3>Setting up an IDE: Haskell Language Server</h3>\n<p>Unfortunately, the Haskell Language Server currently still needs a bit of manual work in order to work.\nBut don't worry, there's not much to do!</p>\n<p>First, HLS uses a system called <a href=\"https://github.com/mpickering/hie-bios\"><code>hie-bios</code></a> which allows it to understand your project configuration.\nAt the time of writing of this article, the automatic detection does not always properly work, and it is advised to write yourself a file <code>./hie.yaml</code> that will explicitly define the project configuration.</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">cradle</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">stack</span><span class=\"mtk1\">:</span></span></span></code></pre>\n<blockquote>\n<p>This file tells HLS that our project is a Stack project, it will detect all the rest by itself: neat!</p>\n</blockquote>\n<p>In order to prevent some possible errors, let's rebuild our project once before launching HLS.</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"bash\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">stack build</span></span></span></code></pre>\n<p>Now that everything is prepared, let's start the Haskell Language Server.\nUse the keyboard shortcut <code>Ctrl+Shift+P</code> and select <code>Haskell: Restart Haskell LSP Server</code>.</p>\n<p>Wait a bit...</p>\n<p>Normally, you should notice that when you hover over <code>putStrLn</code>... documentation should be appearing!\nThis is the work of the VS Code Haskell extension.</p>\n<p><img src=\"/imgs/start-haskell-project/hls%20hover%20works.png\" alt=\"It works (screenshot)\"></p>\n<p>Sometimes the Haskell Language Server takes a bit of time to start, check the status bar at the bottom of VS Code.</p>\n<h2>What now ?</h2>\n<p>Congrats, your setup is ready!</p>\n<p>In order to close this blogpost, I want to quote <a href=\"lexi-lambda.github.io\">Alexis King</a>, who has written a <a href=\"https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/\">splendid guide</a> on Haskell (not for beginners though, hence not really a guide).</p>\n<blockquote>\n<p>Many on the \"outside\" seem to view Haskellers as an elitist, mean-spirited cult, more interested in creating problems for itself than solving them.</p>\n<p>That perception is categorically wrong.</p>\n<p>I have never been in a community of programmers so dedicated and passionate about applying thought and rigor to building software, then going out and actually doing it. [...]\nOne of my primary motivators for writing Haskell is that it is fun and it challenges me intellectually in ways that other languages donâ€™t.\nBut that challenge is not a sign of uselessness, it is a sign that Haskell is so close to letting me do the right thing, to solving the problem the right way, to letting me work without compromises.\nWhen I write in most programming languages, I must constantly accept that my program will never be robust in all the ways I want it to be, and I might as well give up before I even start.\n<strong>Haskellâ€™s greatest weakness is that it tempts me to try.</strong></p>\n</blockquote>\n<p>Now that you have a good setup to start writing Haskell, let yourself be tempted as well. ðŸ™‚</p>\n<p>If you are still a bit afraid of Haskell, you should start reading <a href=\"http://learnyouahaskell.com/chapters\">\"Learn You a Haskell for Great Good!\"\n</a> which is a soft introduction for beginners.</p>\n<p>Happy hacking!</p>\n<h2>Notes</h2>\n<h3>But wait, what is this \"Haskell Platform\"? Why not use it?</h3>\n<p>Oh, are you talking about the <a href=\"https://www.haskell.org/platform/\">Haskell Platform</a>?\nI see you did your homework!</p>\n<p>In my opinion, it has been a nice alternative for beginners for some time.\nHowever, now that the Haskell Language server exists, there is nearly no reason to use the Haskell Platform, which does not use it.</p>\n<p>VS Code is great, HLS is great, the only tricky part is Stack but it can be introduced quite well to beginners, even if it has its pitfalls.</p>\n<h3>Haskell Language Server complains about the GHC version being wrong...</h3>\n<p>Because HLS uses a set of libraries from GHC that change between versions, it is important to use a HLS version that has been compiled against the GHC you are using.</p>\n<p>Fortunatly, there is a HLS wrapper <code>haskell-language-server-wrapper</code> that automatically detects the GHC version of your project and calls the HLS binary that matches your GHC version.</p>\n<h3>I have an issue...</h3>\n<p>First do not panic!</p>\n<p>If you need a point of comparison, you can find the source code for this article <a href=\"https://github.com/GuillaumeDesforges/haskell-guide/tree/master/start-haskell-project-2020\">here</a>.</p>\n<p>As usual, don't hesitate to <a href=\"https://github.com/GuillaumeDesforges/haskell-guide/issues/new\">make an issue</a> if you have any trouble or any question.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-visual-studio {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-visual-studio .mtk3 { color: #6A9955; }\n  .dark-visual-studio .mtk4 { color: #569CD6; }\n  .dark-visual-studio .mtk1 { color: #D4D4D4; }\n  .dark-visual-studio .mtk11 { color: #CE9178; }\n  .dark-visual-studio .mtk5 { color: #B5CEA8; }\n  .dark-visual-studio .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"date":"23-12-2020","path":"/articles/start-haskell-project-2020","title":"Setup a Haskell development environment in 2020","abstract":"A complete guide for beginners","tags":"software engineering, haskell, vs code, guide, beginner"}},"site":{"siteMetadata":{"siteUrl":"https://guillaumedesforges.github.io"}}},"pageContext":{}},"staticQueryHashes":["63159454"]}
{"componentChunkName":"component---src-templates-article-template-js","path":"/articles/learn-haskell-by-doing/01-start","result":{"data":{"markdownRemark":{"html":"<p><em>TODO short introduction about Haskell and the fact that I like learning by doing</em></p>\n<h2>What this guide is about</h2>\n<p>In this project, we are going to develop a small GraphQL server with</p>\n<ul>\n<li>a simple HTTP server</li>\n<li>a <strong>code-first GraphQL</strong> schema</li>\n<li><strong>business logic</strong> with an ORM</li>\n<li>an <strong>authentication</strong> and <strong>authorization</strong> system</li>\n</ul>\n<p>Before starting this project, you should know about</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Web_server\">HTTP servers</a></li>\n<li><a href=\"https://graphql.org/\">GraphQL</a></li>\n<li><a href=\"https://jwt.io/\">JWT</a></li>\n</ul>\n<blockquote>\n<p>While you can probably learn about those while following this guide, I recommand building some knowledge first, so that *you <strong>focus on Haskell here</strong>.</p>\n</blockquote>\n<h2>Development environment</h2>\n<p>If you don't know how to setup a development environment for Haskell, check out my guide <a href=\"https://guillaumedesforges.github.io/articles/start-haskell-project-2020\">\"Setup a Haskell development environment in 2020\"</a> </p>\n<h2>Setup the project</h2>\n<p>Let's first create our project.</p>\n<p><code>stack.yaml</code></p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"1\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">resolver</span><span class=\"mtk1\">: </span><span class=\"mtk11\">lts-16.26</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"2\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">packages</span><span class=\"mtk1\">: [</span><span class=\"mtk11\">&quot;.&quot;</span><span class=\"mtk1\">]</span></span></span></code></pre>\n<p><code>package.yaml</code></p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"yaml\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"1\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">name</span><span class=\"mtk1\">: </span><span class=\"mtk11\">haskell-graphql-example</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"2\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">version</span><span class=\"mtk1\">: </span><span class=\"mtk5\">0.0.0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"3\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">description</span><span class=\"mtk1\">: </span><span class=\"mtk11\">An example of GraphQL server in Haskell for educational content</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"4\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"5\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">author</span><span class=\"mtk1\">: </span><span class=\"mtk11\">Guillaume Desforges &lt;guillaume.desforges.pro@gmail.com&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"6\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">homepage</span><span class=\"mtk1\">: </span><span class=\"mtk11\">http://guillaumedesforges.github.io/articles/learn-haskell-by-doing/01-start</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"7\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"8\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"9\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  - </span><span class=\"mtk11\">base</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"10\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"11\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">library</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"12\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">source-dirs</span><span class=\"mtk1\">: </span><span class=\"mtk11\">src/lib</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"13\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"14\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">executable</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"15\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">source-dirs</span><span class=\"mtk1\">: </span><span class=\"mtk11\">src/exe</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"16\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">main</span><span class=\"mtk1\">: </span><span class=\"mtk11\">Main</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"17\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">dependencies</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"18\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    - </span><span class=\"mtk11\">haskell-graphql-example</span></span></span></code></pre>\n<p>Plus, create folders <code>./src/lib/</code> and <code>./src/exe</code>.</p>\n<p>If you don't know about those files, it means you have not checked out my guide <a href=\"https://guillaumedesforges.github.io/articles/start-haskell-project-2020\">\"Setup a Haskell development environment in 2020\"</a> when you should!\nCome back here after reading it. ðŸ˜‰</p>\n<p>Now let's write our first Haskell code:</p>\n<p><code>src/exe/Main.hs</code></p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"haskell\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"1\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">module</span><span class=\"mtk1\"> Main </span><span class=\"mtk4\">where</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"2\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"3\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">main = print </span><span class=\"mtk11\">&quot;Hello world&quot;</span></span></span></code></pre>\n<p>check that it compiles:</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"bash\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$ stack build</span></span></span></code></pre>\n<p>and that it runs</p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"bash\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$ stack run</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">&quot;Hello world&quot;</span></span></span></code></pre>\n<p>Yosh, everything is set, let's talk about Haskell!</p>\n<h2>How does it work ?</h2>\n<p>Haskell applications are typically structured as follows:</p>\n<ul>\n<li>a library component that contains all the code that we use</li>\n<li>a executable component, which is a very thin wrapper over our library</li>\n</ul>\n<p>In Haskell, only the library component can be imported by other components or project, which is why almost all code should fall into the <code>./src/lib</code> folder.\nSince we have not started anything yet, this folder is empty, but don't worry: this won't be for long.</p>\n<p>Then comes the executable components.\nIn most applications, you will have only one executable component, hence the use in <code>package.yaml</code> of the top-level <code>executable</code> key.</p>\n<p>This component requires two things.\nFirst, the <code>executable.source-dirs</code> key, which defines the folder ocntaining our executable source code.\nThen, the <code>executable.main</code> key, which defines which module we should use as our program entry point.</p>\n<h3>Module ?</h3>\n<p>In any programming language, it is important to organize the source code.\nIn practice, we want to split the source code into \"containers\" from which we can pick whatever we need whenever we need it.</p>\n<p>Imagine that you do some <a href=\"https://en.wikipedia.org/wiki/Do_it_yourself\">DIY</a>.\nYou would have a lot of tools and stuff from all your different needs: screwdrivers, paint brushes, glue, ...\nIf you have a lot of these, would you rather have it all in one messy place, or make smallers compartments that correspond to the different activities, e.g. painting, scrapbooking, wood-turning, ...?</p>\n<p>A <strong>module</strong> is the way to make \"containers of pieces of code\" in Haskell.\nEach module is a set of top-level definitions that can be imported by other modules.</p>\n<p>Each module is characterized by a <strong>module path</strong>.\nVery much like Java's package notation (e.g. <code>com.somepackage.SomeClass</code>), Haskell uses dot notation which is <code>Path.To.Folder.ModuleName</code>.\nBy convention, the module path should reflect the source file path.\nFor instance, if I have a file in a folder <code>./src/lib/Foo/Bar/MyModule.hs</code> in the library component, the module name should be <code>Foo.Bar.MyModule</code>.</p>\n<p>This module name is defined explicitly at the very beginning of the file:</p>\n<p><code>./src/exe/Main.hs</code></p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"haskell\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"1\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">module</span><span class=\"mtk1\"> Main </span><span class=\"mtk4\">where</span></span></span></code></pre>\n<p>Since the file is <code>./src/lib/Main.hs</code>, the module name is just <code>Main</code>.</p>\n<h3>Entry point?</h3>\n<p>Exactly like C, Java and most programming language, we need a \"main\" top level definition.\nBy defining such a \"main\" function to call, programers in imperative languages (like C, C++, Java, ...) can call other functions, which can in turn call other functions, etc... which imperatively define the behavior of the program.\nIn some other language, for instance script languages like Python, there might not always be a \"main\" function, but rather a specific file to interpret in order to start the application.</p>\n<p>Haskell is like C or Java, we define a top-level <code>main</code> element.</p>\n<p><code>./src/exe/Main.hs</code></p>\n<pre class=\"grvsc-container dark-visual-studio\" data-language=\"haskell\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"3\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">main = print </span><span class=\"mtk11\">&quot;Hello world&quot;</span></span></span></code></pre>\n<blockquote>\n<p>We will talk a bit more about this <code>main</code> element later, because it is fondamentally different in Haskell compared to other programming languages.</p>\n</blockquote>\n<p>The GHC compiler will be told to look for a Haskell source code file, and it will automatically try to find this <code>main</code> element in the file.\nIt will then read the instructions defined in it in order to produce the output executable.</p>\n<p>Here, the <code>main</code> element is set to the action <code>print \"Hello world\"</code> which, surprisingly enough, prints \"Hello world\" to the console!</p>\n<p><code>stack run</code> is a shortcut that triggers a build of both the library and the executable components of our package, and then calls the binary executable that was created from it (if the build didn't fail).</p>\n<p>Since we defined in our <code>package.yaml</code> file the <code>executable.source-dirs: src/exe</code> and <code>executable.main: Main</code>, the compiler looks for the <code>Main</code> module of path <code>./src/exe/Main.hs</code>, looks for the element <code>main</code> inside of it and uses it as the entry point of our program.\nIt finds that the <code>main</code> points to <code>print \"Hello world\"</code>, compiles the instructions, and <em>booya</em>, we got ourselves a binary executable!</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-visual-studio {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-visual-studio .mtk4 { color: #569CD6; }\n  .dark-visual-studio .mtk1 { color: #D4D4D4; }\n  .dark-visual-studio .mtk11 { color: #CE9178; }\n  .dark-visual-studio .mtk5 { color: #B5CEA8; }\n  .dark-visual-studio .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"date":null,"path":"/articles/learn-haskell-by-doing/01-start","title":"Learn Haskell by doing - Start [1/1]","abstract":"Haskell in practice, explained to beginners","tags":"software engineering, haskell, guide, beginner"}},"site":{"siteMetadata":{"siteUrl":"https://guillaumedesforges.github.io"}}},"pageContext":{}},"staticQueryHashes":["63159454"]}
{"componentChunkName":"component---src-templates-article-template-js","path":"/articles/nix-guide/1-a-fkin-guide-to-nix","result":{"data":{"markdownRemark":{"html":"<h2>A motivational speech</h2>\n<p>Software engineering is a nightmare.</p>\n<p>We all have all done all-nighters trying to figure out why our code could not compile, how some package update had broken our system, why the application could not deploy, why the production server had crashed, why bugs, <em>why all this</em>?</p>\n<div class=\"figure\">\n<img src=\"/imgs/nix-guide/1/rage-face.jpg\" style=\"max-height: 20em;\"/>\n<p>Sometimes I just want to let it out (credits: <a href=\"https://unsplash.com/@alessandro_bellone\">Alessandro Bellone</a>)</p>\n</div>\n<p>Software engineering is damn hard.\nIf you have not realized it yet, ask your seniors or just wait for a couple of months.\nIt is so complicated that even after more than <a href=\"https://collection.sciencemuseumgroup.org.uk/objects/co62245/babbages-analytical-engine-1834-1871-trial-model-analytical-engines\">a hundred years</a>, we still can barely make things that work!</p>\n<p>In my (humble) opinion, I can see two major factors for that:</p>\n<ul>\n<li>problems in life are usually not that simple, so are programs that are supposed to solve said problems</li>\n<li>software engineering has been under-estimated</li>\n</ul>\n<p>The first point is what make us, developpers, have plenty of work and job opportunities.\nIt doesn't come as a surprise that, life being rarely simple, so are problems (rarely simple).\nSometimes you are lucky enough for the goals to be clear and mature enough so that the scope of your application is well defined: it's the ideal highway.\nMost of the time you are not so lucky.\nMaybe the actual logic of the solution to the actual problem can be easy and straightforward, but attaining said solution will often not be that simple: it's the usual bumpy ride.</p>\n<p>I would like to emphasis the second point especially.\nSoftware engineering is hard.\nIt is a <strong>craftmanship</strong> that require time to master.\nIt is a diverse field that nobody can fully master.\nIt is a job that seems creative when most of the time it is not.\nIt is the art to find the right directions in a place full of pit-holes.\nIt is complicated.</p>\n<p>I am not going to develop this thesis further (maybe this rant/plea is for another time), because I think you can get what I mean: the situation is dire and we need to stop for a moment.\nWe need to stop for a moment and look at what we've done.\nIf we are in this mess, some things should not be right.\nSome things <em>aren't</em> right.</p>\n<p>We have to assume that part of are fundamental thinking was wrong, and that it is not too late to decide to change things.\nI am part of those people, and you can too.\nIt's time to change things from the very basics.</p>\n<p>Now, let's take this step back that we need.\nWhen I contemplate the current state of the IT world, I can see things that I don't like.\nI'm sure you have your own dissatisfaction as well, but for the sake of this article please hear my own.</p>\n<p>Something that I have been frustrated about for years was the hell I have to go through to get my machine to do what I want.\nIf you have tried to develop a bit on Windows back a few years ago for anything that was not Java or C#, you know that the development experience is poor.</p>\n<div class=\"figure\">\n<img src=\"/imgs/nix-guide/1/cryptic-error-windows.png\"/>\n<p>For real Microsoft, what do you want me to make of that?</p>\n</div>\n<p>Maybe you got lucky, but for me and many of my pals it was <em>bad</em>.\nSo one after another, we had to try to use Linux at some point, usually Ubuntu (Mac for the richests), because that was what was advised.\nPersonally, I came to a point where I felt like Ubuntu was limiting me, exactly like when I was using Windows.\nSo here I went again, looking for the next best OS.\nHere came Linux Mint.\nThen Manjaro.\nIt went better and better, but I always had that moment when I got to a point where something was missing.\nAlmost always, it was because of the way the system was configured combined to how its package manager worked.</p>\n<p>In the end, all OS (and eventually package managers) have the same design flaw: things interact too much.\nYou start with a nice and basic system, full of life and joy, but as its life goes you end up with a clonky failing system that refuses to do what you want.\nAfter installing Python 2, then Python 3, then node 12, adding some custom user configuration for a program, going back to Python 2, changing to node 13, upgrading again to Python 3, changing my bash profile, tempering with part of my system to make a specific package work, then changing again my bash profile to fix a bug, and on and on and on... After a few months or years you get to a point where the small change in a specific file lost in your system will prevent another application to work and you will spend a month trying to find it. And once you fix it... it breaks your system.\nA flap of wings of a butterfly will break your computer in a few years.</p>\n<p>Sorry again, have I told you that working with a computer is a nightmare?</p>\n<p>The flaw of all OS and package managers and computers are that they are <strong>stateful</strong>, <strong>dynamic</strong> and <strong>complex</strong> systems that are directed by laws beyond our human understanding.\nFlea, mortals!</p>\n<div class=\"figure\">\n<img src=\"https://imgs.xkcd.com/comics/computer_problems.png\"/>\n<p>\"Computer Problems\" by xkcd</p>\n</div>\n<p>Joke aside, I think it comes from that fact that back in the days... it could not have been done any other way.\nIt was already hard as it was to get the computer to run simple statements, to make programs fit on ridiculous disk spaces, to optimize memory allocation.\nHowever, we are way beyond that point and now that we have incredibly powerful hardware we can stop thinking about optimization as the first problem, but rather put good design as a first priority.</p>\n<p>Now, you are going to tell me: \"but Guillaume, how can we do things any other way?\".\nGlad you asked!\nLet me introduce Nix to you.</p>\n<h2>What is Nix?</h2>\n<p>To be precise, Nix is a <em>programming language</em>.\nBut we'll get to that point later, let's first focus on what's important.</p>\n<p><strong>Nix is an ecosystem</strong> that wants to get rid of the problems I told you about: it wants to make your computer a <strong>stateless</strong>, <strong>static</strong> and <strong>simple</strong> system.\nNix will allow us to turn computers into the machine they were supposed to be, meaning powerful tools that <em>solved</em> problems instead of creating more.</p>\n<p>The main idea of Nix and what I want you to understand right now is that <strong>it turns parts of your computer (from your OS to applications) into individual, immutable pieces that are independant from the rest of your computer and independant from each other</strong>. Please re-read this previous sentence again.</p>\n<p>This means that you will not be able to temper with your OS files, application binaries or even Python environment directly.</p>\n<p>This will be a constraint and, to be honest, it will often get frustrating.\nBut between those moments, you will understand that those rules are safeguards for the sake of your own sanity.\nNix is a story of love and hate, a bit like parents who annoy you for your own good.</p>\n<p>Now let's break down this Nix ecosystem:</p>\n<ul>\n<li><strong>Nix</strong> is both the <strong>command line tool</strong> and the <strong>programming language</strong> to build pieces of your computer system</li>\n<li><strong>nixpkgs</strong> (\"Nix packages\") is a huge <strong>repository</strong> with a lot of Nix code defining all sorts of applications and librairies</li>\n<li><strong>NixOS</strong> is the <strong>operation system</strong> based on Nix and nixpkgs</li>\n</ul>\n<h2>Using Nix for the first time (on Linux)</h2>\n<p>This guide will take you from zero to hero on Nix.\nRight now, we are at the zero.\nHopefully you understood what the problem was and why you are going to use Nix (if not, worry not: it will become clearer with time).\nHowever, you are the John Snow of Nix and know nothing on what it concretly does and how.</p>\n<p>So it's time for a bit of practice!</p>\n<p>Let's get started with the most important: the Nix command line tool.</p>\n<p><em>Side note: if you are not comfortable with experimenting on your own, I will not try to convince you to directly use NixOS.</em>\n<em>If you are a bit of a hacker, I recommand installing and using directly NixOS (at your own risk).</em></p>\n<p><em>Windowers, you can use <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\">WSL</a> to run Linux for the coming steps.</em></p>\n<p>Let's go to a terminal and follow the <a href=\"https://nixos.org/download.html\">official instructions</a> to install Nix:</p>\n<pre><code class=\"language-bash\">$ curl -L https://nixos.org/nix/install | sh\n</code></pre>\n<p>You should close your terminal and reopen it to be sure that all environment variables are set.</p>\n<p>Let's check that it is working:</p>\n<pre><code class=\"language-bash\">$ nix --version\nnix (Nix) 2.3.5\n</code></pre>\n<p>Everything okay?\nCongrats, you successfully completed the first step to awesomeness.\nIf not, you can <a href=\"https://google.com\">search on the web</a> how to fix it.</p>\n<p>Let's now try something meaningful:</p>\n<pre><code class=\"language-bash\">$ nix-shell -p hello\nthese paths will be fetched (0.04 MiB download, 0.20 MiB unpacked):\n  /nix/store/hs6rg4zbsclx660s6i5938605zmv6lgh-hello-2.10\ncopying path '/nix/store/hs6rg4zbsclx660s6i5938605zmv6lgh-hello-2.10' from 'https://cache.nixos.org'...\n\n[nix-shell:~]$ hello\nHello, world!\n</code></pre>\n<p>Without knowing it, you just leveraged a whole lot of technology!\nBut what happened?</p>\n<p>TODO</p>\n<h2>Wait a minute, why do you write this guide?</h2>\n<p>Nix is not yet a mature ecosystem compared to what it tries to achieve.\nThere are a lot of great minds behind it (maybe even geniuses) but <em>god</em> do I feel like Nix is badly (hear wrongly) documented.</p>\n<p>This series of article is supposed to be an accessible user guide for people like me who need clear and progressive explanations.</p>\n<p>It will probably undergo edits in the future, so don't be surprised if it is different in a few months.</p>","frontmatter":{"date":"11-06-2020","path":"/articles/nix-guide/1-a-fkin-guide-to-nix","title":"A f$$ing guide to Nix","abstract":"The user guide we needed, maybe not the one we deserved","tags":"os, coding, software engineering, nix"}},"site":{"siteMetadata":{"siteUrl":"https://guillaumedesforges.github.io"}}},"pageContext":{}}}